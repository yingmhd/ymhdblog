---
layout: mypost
title: JS之函数式编程compose和pip
description: JS函数式编程中compose和pip的实现
keywords: 函数式编程,compose,pip
tags: JS
---

## 前言
关于JS函数式编程，之前已经讨论了其中的![柯里化](https://blog.ymhd.xyz/posts/2019/09/15/%E6%9F%AF%E9%87%8C%E5%8C%96%E4%B8%8E%E5%8F%8D%E6%9F%AF%E9%87%8C%E5%8C%96.html)，另外还有一个`偏函数`，跟`柯里化`非常相似

         
> 柯里化和偏函数的区别
         
偏函数固定了部分参数，生成另外一个参数更少的方法，比如bind()      

今天再学习以下`compose`和`pip`

## compose和pip
应用场景：有一些公用函数，现在需要执行一系列操作，就需要不停的调用这些公用函数，所以就会出现一个接一个的调用，如果有一个函数可以把这些需要调用的函数按照顺序链接起来，直接调用这个函数不就可以了。
```
	// 公共函数，顺序由上至下
	let greeting = (firstname,lastname) => "h1,"+firstname+lastname;
    let toUpper = str => str.toUpperCase();
    let trimSpace = str => str.replace(/\s+/g,'');
```
现在用一个函数把这三个函数包装起来，这个包装函数可以是`compose`或者`pip`

> pip和compose的区别        
pip函数包装函数是根据参数顺序包装`pip([greeting,toUpper,trimSpace])`，而compose是根据参数倒序包装`compose([trimSpace,toUpper,greeting])`

pip 的实现

```
	let pip = function (funcs) {
        let len = funcs.length;
        // 判断参数是否都是函数
        let index = len;
        while (index--) {
            if(typeof funcs[index] !== 'function') {
                throw new TypeError('Excepted  a function');
            }
        }
        return function(...args) {
            let index = 0;
            // 如果没有包装任何一个函数，则返回调用包装函数的第一个参数
            let result = len ? funcs[index].apply(this,args):args[0];
            // 循环绑定
            while (++index<len) {
                result = funcs[index].call(this,result);
            }
            return result;
        }
    };
    // compose的实现
    let compose = function(funcs) {
        return pip(funcs.reverse());
    };
    let fn = flow([greeting,toUpper,cutTrim]);
    console.log(fn('y i n g','m u'));
```
